//! PacketParamedic Reflector - Self-hosted network test endpoint.
//!
//! This binary provides the CLI entry point for the reflector server. It
//! supports several subcommands for running the server, managing peer pairing,
//! rotating the endpoint identity, and inspecting status.

mod audit;
mod auth;
mod cert;
mod config;
mod engine;
mod governance;
mod identity;
mod network;
mod peer;
mod rpc;
mod selftest;
mod server;
mod session;
mod tls;
mod wire;

use std::path::PathBuf;

use anyhow::{Context, Result};
use clap::{Parser, Subcommand};
use tracing::{error, info, warn};

use crate::config::ReflectorConfig;
use crate::identity::Identity;
use crate::server::ReflectorServer;

// ---------------------------------------------------------------------------
// CLI definition
// ---------------------------------------------------------------------------

#[derive(Parser)]
#[command(name = "reflector")]
#[command(about = "PacketParamedic Reflector - Self-hosted network test endpoint")]
#[command(version)]
struct Cli {
    /// Path to configuration file
    #[arg(short, long, env = "REFLECTOR_CONFIG")]
    config: Option<PathBuf>,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Start the reflector server
    Serve {
        /// Override listen address (e.g. "0.0.0.0:7100")
        #[arg(short, long)]
        bind: Option<String>,
    },

    /// Enable pairing mode for a new peer
    Pair {
        /// Time-to-live for pairing window (e.g. "10m", "1h")
        #[arg(long, default_value = "10m")]
        ttl: String,

        /// Accept a code generated by the other side (bidirectional pairing).
        /// If omitted, a new code is generated locally.
        #[arg(long)]
        code: Option<String>,
    },

    /// Rotate the endpoint identity (creates new keypair)
    RotateIdentity,

    /// Show current status
    Status,

    /// Print the endpoint ID
    ShowId,

    /// Run hardware self-test (checks if host can push 1 Gbps)
    SelfTest {
        /// Output results as JSON instead of human-readable table
        #[arg(long)]
        json: bool,
    },
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

#[tokio::main]
async fn main() {
    let cli = Cli::parse();

    // Load configuration.
    let config = match load_config(cli.config.as_deref()) {
        Ok(c) => c,
        Err(e) => {
            eprintln!("Error loading configuration: {e:#}");
            std::process::exit(1);
        }
    };

    // Initialize tracing subscriber.
    init_tracing(&config);

    let result = match cli.command {
        Commands::Serve { bind } => cmd_serve(config, bind).await,
        Commands::Pair { ttl, code } => cmd_pair(config, ttl, code).await,
        Commands::RotateIdentity => cmd_rotate_identity(config),
        Commands::Status => cmd_status(config),
        Commands::ShowId => cmd_show_id(config),
        Commands::SelfTest { json } => cmd_self_test(config, json).await,
    };

    if let Err(e) = result {
        error!(error = %e, "command failed");
        eprintln!("Error: {e:#}");
        std::process::exit(1);
    }
}

// ---------------------------------------------------------------------------
// Config loading
// ---------------------------------------------------------------------------

/// Load the reflector configuration from a file (if given) or fall back to
/// defaults.
fn load_config(path: Option<&std::path::Path>) -> Result<ReflectorConfig> {
    match path {
        Some(p) => {
            ReflectorConfig::load(p)
                .with_context(|| format!("failed to load config from {}", p.display()))
        }
        None => {
            // Try well-known locations, then fall back to defaults.
            let candidates = [
                PathBuf::from("/etc/reflector/reflector.toml"),
                dirs_or_default().join("reflector.toml"),
            ];

            for candidate in &candidates {
                if candidate.exists() {
                    info!(path = %candidate.display(), "found config file");
                    return ReflectorConfig::load(candidate).with_context(|| {
                        format!("failed to load config from {}", candidate.display())
                    });
                }
            }

            info!("no config file found, using defaults");
            Ok(ReflectorConfig::default())
        }
    }
}

/// Return a sensible default configuration directory.
fn dirs_or_default() -> PathBuf {
    // XDG_CONFIG_HOME or ~/.config/reflector
    std::env::var_os("XDG_CONFIG_HOME")
        .map(PathBuf::from)
        .unwrap_or_else(|| {
            let mut home = dirs_home();
            home.push(".config");
            home
        })
        .join("reflector")
}

/// Best-effort home directory lookup.
fn dirs_home() -> PathBuf {
    std::env::var_os("HOME")
        .map(PathBuf::from)
        .unwrap_or_else(|| PathBuf::from("."))
}

// ---------------------------------------------------------------------------
// Tracing initialization
// ---------------------------------------------------------------------------

/// Initialize the tracing subscriber using the config's log level.
fn init_tracing(config: &ReflectorConfig) {
    let log_level = config.logging.level.clone();
    let env_filter = tracing_subscriber::EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new(log_level));

    tracing_subscriber::fmt()
        .with_env_filter(env_filter)
        .with_target(true)
        .with_thread_ids(false)
        .with_file(false)
        .with_line_number(false)
        .init();
}

// ---------------------------------------------------------------------------
// Subcommand implementations
// ---------------------------------------------------------------------------

/// `serve` -- Start the reflector server.
async fn cmd_serve(mut config: ReflectorConfig, bind_override: Option<String>) -> Result<()> {
    if let Some(addr) = bind_override {
        config.network.listen_address = addr;
    }

    // Spawn HTTP health check server.
    let health_addr = config.network.listen_address_health.clone();
    tokio::spawn(async move {
        info!(address = %health_addr, "starting health check listener");
        match tokio::net::TcpListener::bind(&health_addr).await {
            Ok(listener) => {
                let app = engine::health::build_health_router();
                if let Err(e) = axum::serve(listener, app).await {
                    error!(error = %e, "health server failed");
                }
            }
            Err(e) => {
                error!(error = %e, address = %health_addr, "failed to bind health listener");
            }
        }
    });

    let server = ReflectorServer::new(config)
        .await
        .context("failed to initialize reflector server")?;

    server.run().await
}

/// `pair` -- Enable pairing mode for a new peer.
///
/// Supports bidirectional pairing:
/// - Without `--code`: generates a new 8-character code (reflector-initiated)
/// - With `--code ABCD1234`: accepts a code from the other side (appliance-initiated)
async fn cmd_pair(config: ReflectorConfig, ttl: String, code: Option<String>) -> Result<()> {
    let identity_dir = config
        .identity
        .private_key_path
        .parent()
        .unwrap_or(std::path::Path::new("/var/lib/reflector"));
    let identity_path = identity_dir.join("identity.key");
    let identity = Identity::load_or_generate(&identity_path)
        .context("failed to load identity")?;

    let endpoint_id = identity.endpoint_id();

    // Parse TTL string (e.g. "10m", "1h", "30s").
    let ttl_secs = parse_duration_str(&ttl)
        .context("failed to parse TTL duration")?;

    let auth_gate = auth::AuthGate::new(&config.access);

    let is_external_code = code.is_some();
    let token = match code {
        Some(c) => {
            // Bidirectional: accept a code from the other side.
            if c.len() != 8 || !c.chars().all(|ch| ch.is_ascii_alphanumeric()) {
                anyhow::bail!(
                    "pairing code must be exactly 8 alphanumeric characters, got: {:?}",
                    c
                );
            }
            auth_gate
                .enable_pairing_with_code(std::time::Duration::from_secs(ttl_secs), c)
                .await
        }
        None => {
            // Reflector-initiated: generate a new code.
            auth_gate
                .enable_pairing(std::time::Duration::from_secs(ttl_secs))
                .await
        }
    };

    println!();
    println!("  Pairing Mode Enabled");
    println!("  ====================");
    println!("  Endpoint ID    : {}", endpoint_id);
    println!("  Pairing Code   : {}", token.token);
    println!("  Expires In     : {}", ttl);
    println!();
    if is_external_code {
        println!("  Waiting for peer to connect with this code.");
        println!("  The peer must connect within the TTL window to be authorized.");
    } else {
        println!("  Share this code with the peer (appliance or reflector).");
        println!("  The peer enters the code to establish a long-term pairing.");
    }
    println!();

    Ok(())
}

/// `rotate-identity` -- Generate a new Ed25519 keypair.
fn cmd_rotate_identity(config: ReflectorConfig) -> Result<()> {
    let identity_dir = config
        .identity
        .private_key_path
        .parent()
        .unwrap_or(std::path::Path::new("/var/lib/reflector"));
    let identity_path = identity_dir.join("identity.key");

    // Warn if an existing key will be overwritten.
    if identity_path.exists() {
        warn!(
            path = %identity_path.display(),
            "rotating identity will overwrite the existing keypair"
        );
        println!("WARNING: This will overwrite the existing identity keypair.");
        println!("         All previously paired peers will need to re-pair.");
        println!();
    }

    let identity = Identity::generate();
    identity
        .save(&identity_path)
        .context("failed to save new identity")?;

    let endpoint_id = identity.endpoint_id();

    println!("  Identity Rotated");
    println!("  ================");
    println!("  New Endpoint ID : {}", endpoint_id);
    println!("  Key File        : {}", identity_path.display());
    println!();
    println!("  IMPORTANT: All peers must re-pair with the new endpoint ID.");
    println!();

    Ok(())
}

/// `status` -- Show current reflector status.
///
/// For now this prints the identity and configuration. Full RPC-based status
/// queries will be added in a later phase.
fn cmd_status(config: ReflectorConfig) -> Result<()> {
    let identity_dir = config
        .identity
        .private_key_path
        .parent()
        .unwrap_or(std::path::Path::new("/var/lib/reflector"));
    let identity_path = identity_dir.join("identity.key");

    if !identity_path.exists() {
        println!("  No identity found. Run `reflector serve` to generate one.");
        return Ok(());
    }

    let identity = Identity::load(&identity_path)
        .context("failed to load identity")?;

    let net_position = network::resolve_position(&config.network.deployment_mode);

    println!();
    println!("  Reflector Status");
    println!("  ================");
    println!("  Endpoint ID   : {}", identity.endpoint_id());
    println!("  Bind Address  : {}", config.network.listen_address);
    println!("  Mode          : {:?}", config.network.mode);
    println!("  Network       : {}", net_position);
    println!("  Data Dir      : {}", identity_dir.display());
    println!();

    Ok(())
}

/// `show-id` -- Print the endpoint ID.
fn cmd_show_id(config: ReflectorConfig) -> Result<()> {
    let identity_dir = config
        .identity
        .private_key_path
        .parent()
        .unwrap_or(std::path::Path::new("/var/lib/reflector"));
    let identity_path = identity_dir.join("identity.key");

    if !identity_path.exists() {
        println!("  No identity found. Run `reflector serve` to generate one.");
        return Ok(());
    }

    let identity = Identity::load(&identity_path)
        .context("failed to load identity")?;

    println!("{}", identity.endpoint_id());

    Ok(())
}

/// `self-test` -- Run hardware self-test to check 1 Gbps readiness.
async fn cmd_self_test(config: ReflectorConfig, json: bool) -> Result<()> {
    let report = selftest::run(&config).await;

    if json {
        let json_str = serde_json::to_string_pretty(&report)
            .context("failed to serialize self-test report")?;
        println!("{}", json_str);
    } else {
        selftest::print_report(&report);
    }

    // Exit with non-zero if not ready
    if report.verdict.starts_with("NOT READY") {
        std::process::exit(2);
    }

    Ok(())
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/// Parse a human-readable duration string like "10m", "1h", "30s" into seconds.
fn parse_duration_str(s: &str) -> Result<u64> {
    let s = s.trim();
    if s.is_empty() {
        anyhow::bail!("empty duration string");
    }

    let (num_str, suffix) = if s.ends_with('s') {
        (&s[..s.len() - 1], "s")
    } else if s.ends_with('m') {
        (&s[..s.len() - 1], "m")
    } else if s.ends_with('h') {
        (&s[..s.len() - 1], "h")
    } else if s.ends_with('d') {
        (&s[..s.len() - 1], "d")
    } else {
        // Assume seconds if no suffix.
        (s, "s")
    };

    let num: u64 = num_str
        .parse()
        .with_context(|| format!("invalid number in duration: {:?}", num_str))?;

    let secs = match suffix {
        "s" => num,
        "m" => num * 60,
        "h" => num * 3600,
        "d" => num * 86400,
        _ => unreachable!(),
    };

    Ok(secs)
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_duration_seconds() {
        assert_eq!(parse_duration_str("30s").unwrap(), 30);
        assert_eq!(parse_duration_str("0s").unwrap(), 0);
        assert_eq!(parse_duration_str("120s").unwrap(), 120);
    }

    #[test]
    fn test_parse_duration_minutes() {
        assert_eq!(parse_duration_str("10m").unwrap(), 600);
        assert_eq!(parse_duration_str("1m").unwrap(), 60);
    }

    #[test]
    fn test_parse_duration_hours() {
        assert_eq!(parse_duration_str("1h").unwrap(), 3600);
        assert_eq!(parse_duration_str("24h").unwrap(), 86400);
    }

    #[test]
    fn test_parse_duration_days() {
        assert_eq!(parse_duration_str("1d").unwrap(), 86400);
        assert_eq!(parse_duration_str("7d").unwrap(), 604800);
    }

    #[test]
    fn test_parse_duration_no_suffix() {
        assert_eq!(parse_duration_str("60").unwrap(), 60);
    }

    #[test]
    fn test_parse_duration_invalid() {
        assert!(parse_duration_str("").is_err());
        assert!(parse_duration_str("abc").is_err());
        assert!(parse_duration_str("m").is_err());
    }

    #[test]
    fn test_parse_duration_whitespace() {
        assert_eq!(parse_duration_str("  10m  ").unwrap(), 600);
    }

    #[test]
    fn test_dirs_or_default_returns_path() {
        let path = dirs_or_default();
        assert!(path.to_str().is_some());
        assert!(path.to_str().unwrap().contains("reflector"));
    }

    #[test]
    fn test_cli_parse_serve() {
        let cli = Cli::try_parse_from(["reflector", "serve"]).unwrap();
        assert!(matches!(cli.command, Commands::Serve { bind: None }));
    }

    #[test]
    fn test_cli_parse_serve_with_bind() {
        let cli = Cli::try_parse_from(["reflector", "serve", "--bind", "0.0.0.0:9999"]).unwrap();
        match cli.command {
            Commands::Serve { bind } => assert_eq!(bind.as_deref(), Some("0.0.0.0:9999")),
            _ => panic!("expected Serve"),
        }
    }

    #[test]
    fn test_cli_parse_pair() {
        let cli = Cli::try_parse_from(["reflector", "pair"]).unwrap();
        match cli.command {
            Commands::Pair { ttl, code } => {
                assert_eq!(ttl, "10m");
                assert!(code.is_none());
            }
            _ => panic!("expected Pair"),
        }
    }

    #[test]
    fn test_cli_parse_pair_with_ttl() {
        let cli = Cli::try_parse_from(["reflector", "pair", "--ttl", "1h"]).unwrap();
        match cli.command {
            Commands::Pair { ttl, code } => {
                assert_eq!(ttl, "1h");
                assert!(code.is_none());
            }
            _ => panic!("expected Pair"),
        }
    }

    #[test]
    fn test_cli_parse_pair_with_code() {
        let cli = Cli::try_parse_from(["reflector", "pair", "--code", "ABCD1234"]).unwrap();
        match cli.command {
            Commands::Pair { ttl, code } => {
                assert_eq!(ttl, "10m");
                assert_eq!(code.as_deref(), Some("ABCD1234"));
            }
            _ => panic!("expected Pair"),
        }
    }

    #[test]
    fn test_cli_parse_pair_with_code_and_ttl() {
        let cli = Cli::try_parse_from(["reflector", "pair", "--code", "XY789ZAB", "--ttl", "5m"]).unwrap();
        match cli.command {
            Commands::Pair { ttl, code } => {
                assert_eq!(ttl, "5m");
                assert_eq!(code.as_deref(), Some("XY789ZAB"));
            }
            _ => panic!("expected Pair"),
        }
    }

    #[test]
    fn test_cli_parse_rotate_identity() {
        let cli = Cli::try_parse_from(["reflector", "rotate-identity"]).unwrap();
        assert!(matches!(cli.command, Commands::RotateIdentity));
    }

    #[test]
    fn test_cli_parse_status() {
        let cli = Cli::try_parse_from(["reflector", "status"]).unwrap();
        assert!(matches!(cli.command, Commands::Status));
    }

    #[test]
    fn test_cli_parse_show_id() {
        let cli = Cli::try_parse_from(["reflector", "show-id"]).unwrap();
        assert!(matches!(cli.command, Commands::ShowId));
    }

    #[test]
    fn test_cli_parse_self_test() {
        let cli = Cli::try_parse_from(["reflector", "self-test"]).unwrap();
        assert!(matches!(cli.command, Commands::SelfTest { json: false }));
    }

    #[test]
    fn test_cli_parse_self_test_json() {
        let cli = Cli::try_parse_from(["reflector", "self-test", "--json"]).unwrap();
        assert!(matches!(cli.command, Commands::SelfTest { json: true }));
    }

    #[test]
    fn test_cli_parse_config_env() {
        // Verify the config arg accepts the env var attribute.
        let cli = Cli::try_parse_from(["reflector", "-c", "/tmp/test.toml", "show-id"]).unwrap();
        assert_eq!(cli.config.as_deref(), Some(std::path::Path::new("/tmp/test.toml")));
    }
}
